jQuery.fn.load = function( url, params, callback ) {
var selector, type, response,
self = this,
off = url.indexOf( " " );if ( off > -1 ) {
selector = stripAndCollapse( url.slice( off ) );
url = url.slice( 0, off );
}if ( isFunction( params ) ) {callback = params;
params = undefined;} else if ( params && typeof params === "object" ) {
type = "POST";
}if ( self.length > 0 ) {
jQuery.ajax( {
url: url,type: type || "GET",
dataType: "html",
data: params
} ).done( function( responseText ) {response = arguments;self.html( selector ?jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :responseText );} ).always( callback && function( jqXHR, status ) {
self.each( function() {
callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
} );
} );
}return this;
};
jQuery.expr.pseudos.animated = function( elem ) {
return jQuery.grep( jQuery.timers, function( fn ) {
return elem === fn.elem;
} ).length;
};
jQuery.offset = {
setOffset: function( elem, options, i ) {
var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
position = jQuery.css( elem, "position" ),
curElem = jQuery( elem ),
props = {};if ( position === "static" ) {
elem.style.position = "relative";
}curOffset = curElem.offset();
curCSSTop = jQuery.css( elem, "top" );
curCSSLeft = jQuery.css( elem, "left" );
calculatePosition = ( position === "absolute" || position === "fixed" ) &&
( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;if ( calculatePosition ) {
curPosition = curElem.position();
curTop = curPosition.top;
curLeft = curPosition.left;} else {
curTop = parseFloat( curCSSTop ) || 0;
curLeft = parseFloat( curCSSLeft ) || 0;
}if ( isFunction( options ) ) {options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
}if ( options.top != null ) {
props.top = ( options.top - curOffset.top ) + curTop;
}
if ( options.left != null ) {
props.left = ( options.left - curOffset.left ) + curLeft;
}if ( "using" in options ) {
options.using.call( elem, props );} else {
curElem.css( props );
}
}
};jQuery.fn.extend( {offset: function( options ) {if ( arguments.length ) {
return options === undefined ?
this :
this.each( function( i ) {
jQuery.offset.setOffset( this, options, i );
} );
}var rect, win,
elem = this[ 0 ];if ( !elem ) {
return;
}if ( !elem.getClientRects().length ) {
return { top: 0, left: 0 };
}rect = elem.getBoundingClientRect();
win = elem.ownerDocument.defaultView;
return {
top: rect.top + win.pageYOffset,
left: rect.left + win.pageXOffset
};
},position: function() {
if ( !this[ 0 ] ) {
return;
}var offsetParent, offset, doc,
elem = this[ 0 ],
parentOffset = { top: 0, left: 0 };if ( jQuery.css( elem, "position" ) === "fixed" ) {offset = elem.getBoundingClientRect();} else {
offset = this.offset();doc = elem.ownerDocument;
offsetParent = elem.offsetParent || doc.documentElement;
while ( offsetParent &&
( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
jQuery.css( offsetParent, "position" ) === "static" ) {offsetParent = offsetParent.parentNode;
}
if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {parentOffset = jQuery( offsetParent ).offset();
parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
}
}return {
top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
};
},offsetParent: function() {
return this.map( function() {
var offsetParent = this.offsetParent;while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
offsetParent = offsetParent.offsetParent;
}return offsetParent || documentElement;
} );
}
} );jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
var top = "pageYOffset" === prop;jQuery.fn[ method ] = function( val ) {
return access( this, function( elem, method, val ) {var win;
if ( isWindow( elem ) ) {
win = elem;
} else if ( elem.nodeType === 9 ) {
win = elem.defaultView;
}if ( val === undefined ) {
return win ? win[ prop ] : elem[ method ];
}if ( win ) {
win.scrollTo(
!top ? val : win.pageXOffset,
top ? val : win.pageYOffset
);} else {
elem[ method ] = val;
}
}, method, val, arguments.length );
};
} );jQuery.each( [ "top", "left" ], function( _i, prop ) {
jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
function( elem, computed ) {
if ( computed ) {
computed = curCSS( elem, prop );return rnumnonpx.test( computed ) ?
jQuery( elem ).position()[ prop ] + "px" :
computed;
}
}
);
} );
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
jQuery.each( {
padding: "inner" + name,
content: type,
"": "outer" + name
}, function( defaultExtra, funcName ) {jQuery.fn[ funcName ] = function( margin, value ) {
var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );return access( this, function( elem, type, value ) {
var doc;if ( isWindow( elem ) ) {return funcName.indexOf( "outer" ) === 0 ?
elem[ "inner" + name ] :
elem.document.documentElement[ "client" + name ];
}if ( elem.nodeType === 9 ) {
doc = elem.documentElement;return Math.max(
elem.body[ "scroll" + name ], doc[ "scroll" + name ],
elem.body[ "offset" + name ], doc[ "offset" + name ],
doc[ "client" + name ]
);
}return value === undefined ?jQuery.css( elem, type, extra ) :jQuery.style( elem, type, value, extra );
}, type, chainable ? margin : undefined, chainable );
};
} );
} );
jQuery.each( [
"ajaxStart",
"ajaxStop",
"ajaxComplete",
"ajaxError",
"ajaxSuccess",
"ajaxSend"
], function( _i, type ) {
jQuery.fn[ type ] = function( fn ) {
return this.on( type, fn );
};
} );
jQuery.fn.extend( {bind: function( types, data, fn ) {
return this.on( types, null, data, fn );
},
unbind: function( types, fn ) {
return this.off( types, null, fn );
},delegate: function( selector, types, data, fn ) {
return this.on( types, selector, data, fn );
},
undelegate: function( selector, types, fn ) {return arguments.length === 1 ?
this.off( selector, "**" ) :
this.off( types, selector || "**", fn );
},hover: function( fnOver, fnOut ) {
return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
}
} );jQuery.each(
( "blur focus focusin focusout resize scroll click dblclick " +
"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
"change select submit keydown keypress keyup contextmenu" ).split( " " ),
function( _i, name ) {jQuery.fn[ name ] = function( data, fn ) {
return arguments.length > 0 ?
this.on( name, null, data, fn ) :
this.trigger( name );
};
}
);
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;jQuery.proxy = function( fn, context ) {
var tmp, args, proxy;if ( typeof context === "string" ) {
tmp = fn[ context ];
context = fn;
fn = tmp;
}if ( !isFunction( fn ) ) {
return undefined;
}args = slice.call( arguments, 2 );
proxy = function() {
return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
};proxy.guid = fn.guid = fn.guid || jQuery.guid++;return proxy;
};jQuery.holdReady = function( hold ) {
if ( hold ) {
jQuery.readyWait++;
} else {
jQuery.ready( true );
}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;jQuery.now = Date.now;jQuery.isNumeric = function( obj ) {var type = jQuery.type( obj );
return ( type === "number" || type === "string" ) &&!isNaN( obj - parseFloat( obj ) );
};jQuery.trim = function( text ) {
return text == null ?
"" :
( text + "" ).replace( rtrim, "" );
};if ( typeof define === "function" && define.amd ) {
define( "jquery", [], function() {
return jQuery;
} );
}
var_jQuery = window.jQuery,_$ = window.$;jQuery.noConflict = function( deep ) {
if ( window.$ === jQuery ) {
window.$ = _$;
}if ( deep && window.jQuery === jQuery ) {
window.jQuery = _jQuery;
}return jQuery;
};if ( typeof noGlobal === "undefined" ) {
window.jQuery = window.$ = jQuery;
}
return jQuery;
} );
